## Best Practices for Persisting Loro Documents

The simplest approach is to use full snapshots for both import and export
operations. Here's how it works:

1. Import the entire snapshot when loading the document.
2. Export a complete snapshot when saving changes.
3. Implement a debounce or throttle mechanism to trigger snapshot saves after a
   certain number of edits.

This method simplifies initial application development but has a drawback: user
edits are not immediately saved. Let's explore how to quickly save each user
edit while minimizing resource consumption.

### Balancing Quick Saves and Resource Efficiency

To achieve both quick saves and resource efficiency:

- Use [`Snapshot Encoding`](./encoding#snapshot-encoding) to periodically store the entire document.
- Use [`Updates Encoding`](./encoding#updates-encoding) to export delta updates frequently (e.g., after each
  keystroke or with debounce/throttle). Store these binary data in fast-write
  storage like user disks or a key-value database. This ensures quick saves with
  low resource cost.
- When loading a document, import the snapshot and all related updates to get
  the latest version.
- After importing, export a new snapshot to replace the old one and remove
  imported updates for faster future loading.
- If your `LoroDoc` has grown large and older history can be safely recycled,
  use `Shallow Snapshot Encoding` to reduce snapshot size. You can archive the
  history before the shallow snapshot's start version in cold storage.

For collaboration, the binary data generated by snapshot/updates can be
transmitted through any medium, such as WebRTC, WebSocket, or HTTP.

The strong eventual consistency in CRDTs ensures that peers with identical sets
of operations will converge to the same document state, obviating concerns about
the order, duplication, or timing of operation delivery.
