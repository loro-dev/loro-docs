# PeerID Management

## Quick Reference

**Peer IDs** are unique identifiers for each editing session in Loro's distributed system. They ensure operation uniqueness without coordination between peers.

## Key Concepts

- **Peer ID**: A 64-bit unique identifier for each client/session
- **Operation ID**: Combination of `(peerId, counter)` that uniquely identifies each operation
- **Counter**: Monotonically increasing number starting at 0 for each peer

```ts
interface OpId {
  peerId: string | number;  // Unique peer identifier
  counter: number;           // Monotonically increasing counter
}
```

## Peer ID Assignment

### Automatic (Default)

```ts twoslash
import { LoroDoc } from "loro-crdt";
// ---cut---
const doc = new LoroDoc(); // Gets a random peer ID
// Safe, no coordination needed, 2^64 possible values
```

**Note**: New peer ID generated for each `LoroDoc` instance, even when loading same document.

### Manual

```ts twoslash
import { LoroDoc } from "loro-crdt";
// ---cut---
const doc = new LoroDoc();
doc.setPeerId("alice");  // String IDs converted to numbers internally
// Or: doc.setPeerId(12345);
```

⚠️ **Warning**: Manual assignment requires careful conflict avoidance.

## Counter System

Each peer maintains a monotonic counter starting at 0:

```ts twoslash
import { LoroDoc } from "loro-crdt";
// ---cut---
const doc = new LoroDoc();
doc.setPeerId("alice");
const text = doc.getText("text");

text.insert(0, "H");    // Operation (alice, 0)
text.insert(1, "i");    // Operation (alice, 1)
console.log(doc.version()); // { alice: 2 }
```

**Properties**: Monotonic, continuous, per-peer, persistent.

## Avoiding Conflicts

### Recommended Strategies

1. **Use Automatic Assignment** (Safest)
```ts twoslash
import { LoroDoc } from "loro-crdt";
// ---cut---
const doc = new LoroDoc(); // Let Loro handle it
```

2. **UUID-Based IDs**
```ts twoslash
import { LoroDoc } from "loro-crdt";
// ---cut---
const doc = new LoroDoc();
doc.setPeerId(crypto.randomUUID());
```

3. **Structured IDs**
```ts twoslash
import { LoroDoc } from "loro-crdt";
// ---cut---
const peerId = `${deviceId}-${Date.now()}-${Math.random()}`;
doc.setPeerId(peerId);
```

### Common Pitfalls

❌ **Never**:
- Use user IDs as peer IDs
- Use fixed IDs like "frontend-app"
- Reuse IDs without proper management

## Best Practices

- **Initial content**: Load from shared snapshot, don't create in each peer
- **Track peer-to-user mappings**: Store associations in document
- **Monitor usage**: Track active peers and operation counts
- **Use frontiers over version vectors**: More compact representation


## Code Example

```ts twoslash
import { LoroDoc } from "loro-crdt";
// ---cut---
// Real-time collaborative editor
class CollaborativeEditor {
  private doc: LoroDoc;
  
  constructor() {
    this.doc = new LoroDoc(); // Auto-generated peer ID
    this.setupSync();
  }
  
  private setupSync() {
    // Track peer metadata on first commit
    this.doc.subscribeFirstCommitFromPeer((event) => {
      this.doc.getMap("peers").set(event.peer, {
        joinedAt: Date.now(),
        isOnline: true
      });
    });
    
    // Subscribe to local updates for sync
    this.doc.subscribeLocalUpdates((update) => {
      // Send update to other peers
      this.broadcast(update);
    });
  }
  
  private broadcast(update: Uint8Array) {
    // Implementation depends on transport
  }
}
```

## Related Documentation

- [Version Representations](./version_representations) - How peer IDs form version vectors
- [Import Status](./import_status) - Handling synchronization with peer IDs
- [Shallow Snapshots](./shallow_snapshots) - Consolidating peer history